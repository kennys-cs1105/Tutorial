# CPP基础、语法、特性

*Created by KennyS*

---


## Tutorial

1. 值传递和引用传递的区别
    - 值传递：函数调用的时候会触发一次参数的拷贝动作，对参数的修改不会影响原始的值，如果是较大的对象，复制整个对象，效率较低
    - 引用传递：函数调用的时候，函数接收的就是参数的引用，不会触发参数的拷贝动作，效率较高，但对参数的修改会直接作用于原始的值


*值传递*
```cpp
void modify_value(int value) {
    value = 100; // 只会修改函数内部的副本，不会影响原始变量
}

int main() {
    int a = 20;
    modify_value(a);
    std::cout << a; // 20，没变
    return 0;
}
```

*引用传递*
```cpp
void modify_value(int& value) {
    value = 100; // 修改引用指向的原始变量
}

int main() {
    int a = 20;
    modify_value(a);
    std::cout << a; // 100，因为是引用传递，所以这里已经改为了100
    return 0;
}
```

**深入理解**

- 什么场景下使用引用传递
    - 避免不必要的数据拷贝：对于比较大的对象参数（vector, string, list），因为拷贝，值传递会导致大量的内存和时间开销，引用传递可以避免
    - 允许函数修改实参原始值

- 什么场景下使用值传递
    - 小型数据结构：对于int, float, double, char等基础数据类型，可以直接简单使用值传递
    - 不希望函数修改实参


---

2. 左值和右值

    - 左值：可以出现在赋值运算符的左边，可以被取地址，通常是有名字的变量
    - 右值：不能出现在赋值运算符的左边，不可以被取地址，表示一个具体的数据值，通常是常量、临时变量


可以从两个方面区分左值和右值

*方向1*
- 可以放到等号左边的东西叫左值
- 不可以放到等号左边的东西叫右值

*方向2*
- 可以取地址并且有名字的东西就是左值
- 不能取地址的没有名字的东西就是右值


*示例1*

```cpp
int a = b + c; 
// b+c返回的是右值，没有名字也不能取地址，&(b+c)不能通过编译
```

*示例2*

```cpp
int a = 4; // a是左值，4作为普通字面量是右值
```

**扩展**

- 左值引用：对左值的引用，等号右边的值必须可以取地址，如果不能取地址则会编译失败，或者可以使用const引用，这样就只能通过引用来读取输出，不能修改数组

```cpp
int a = 5;
int &b = a; // b是左值引用
b = 4;
int &c = 10; // error，10无法取地址，无法进行引用
const int &d = 10; // ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址
```

- 右值引用：对右值的引用，对一个临时对象或者即将被销毁的对象的引用；如果使用右值引用，那么等号右边的值需要是右值，可以使用`std::move`函数强制把左值转换为右值

```cpp
int a = 4;
int &&b = a; // error, a是左值
int &&c = std::move(a); // ok
```


**使用场景**

- 左值引用：需要修改对象的值，或者需要引用一个持久对象时使用
- 右值引用：需要处理一个临时对象，并且想要避免复制，或者实现移动语义时使用


**纯右值**

纯右值属于右值：
    - 除字符串字面值外的字面值
    - 返回非引用类型的函数调用
    - 后置自增自减表达式`i++`, `i--`
    - 算数表达式`a+b`,  `a*b`, `a==b`
    - 取地址表达式 `&a`


**将亡值**

将亡值属于右值，通常指将要被移动的对象，通过盗取其他变量内存空间方式获取的值，在确保其他变量不再被使用或即将被销毁时，可以避免内存空间的释放和分配，演唱变量值的生命周期，常用来完成移动构造或者移动赋值

```cpp
class A {};
A a;
auto c = std::move(a); // c是将亡值
auto d = static_cast<A&&>(a); // d是将亡值
```
